package threadstudy;

/**
 * Created by firstsword on 2019/2/12.
 */
public class VolatileDemo3 {
    int a = 1;
    boolean status = false;

    /**
     * 状态切换为true
     */
    public void changeStatus() {
        a = 2;//1
        status = true;//2
    }

    /**
     * 若状态为true，则running。
     */
    public void run() {
        if (status) {//3
            int b = a + 1;//4
            System.out.println(b);
        }
    }
}

/*
volatile还有一个特性：禁止指令重排序优化。

重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。但是重排序也需要遵守一定规则：

　　1.重排序操作不会对存在数据依赖关系的操作进行重排序。

　　　　比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。

　　2.重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变

　　　　比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系，所以可能会发生重排序，
但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。

　　重排序在单线程模式下是一定会保证最终结果的正确性，但是在多线程环境下，
问题就出来了，来开个例子，我们对第一个TestVolatile的例子稍稍改进，再增加个共享变量a


假设线程A执行changeStatus后，线程B执行run，我们能保证在4处，b一定等于3么？

　　答案依然是无法保证！也有可能b仍然为2。上面我们提到过，为了提供程序并行度，编译器和处理器可能会对指令进行重排序，
而上例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。
而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。

　　使用volatile关键字修饰共享变量便可以禁止这种重排序。若用volatile修饰共享变量，
在编译时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序

　　volatile禁止指令重排序也有一些规则，简单列举一下：

　　1.当第二个操作是voaltile写时，无论第一个操作是什么，都不能进行重排序

　　2.当地一个操作是volatile读时，不管第二个操作是什么，都不能进行重排序

　　3.当第一个操作是volatile写时，第二个操作是volatile读时，不能进行重排序*/
